/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core";
import * as MavenAGI from "../../../index";
import { PublishEvent } from "../../../../serialization/resources/realtime/types/PublishEvent";
import { SubscribeEvent } from "../../../../serialization/resources/realtime/types/SubscribeEvent";

export declare namespace RealtimeSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response = MavenAGI.SubscribeEvent & {
        receivedAt: Date;
    };
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class RealtimeSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: RealtimeSocket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = JSON.parse(event.data);

        const parsedResponse = SubscribeEvent.parse(data, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
            breadcrumbsPrefix: ["response"],
        });
        if (parsedResponse.ok) {
            this.eventHandlers.message?.({
                ...parsedResponse.value,
                receivedAt: new Date(),
            });
        } else {
            this.eventHandlers.error?.(new Error(`Received unknown message type`));
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message ?? "core.ReconnectingWebSocket error";
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: RealtimeSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     */
    public on<T extends keyof RealtimeSocket.EventHandlers>(event: T, callback: RealtimeSocket.EventHandlers[T]) {
        this.eventHandlers[event] = callback;
    }

    public sendMessage(message: MavenAGI.PublishEvent): void {
        this.assertSocketIsOpen();
        this.sendJson(message);
    }

    public connect(): RealtimeSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    public async tillSocketOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    public sendJson(payload: MavenAGI.PublishEvent): void {
        const jsonPayload = PublishEvent.jsonOrThrow(payload, {
            unrecognizedObjectKeys: "strip",
            allowUnrecognizedUnionMembers: true,
            allowUnrecognizedEnumValues: true,
            skipValidation: true,
        });
        this.socket.send(JSON.stringify(jsonPayload));
    }
}
