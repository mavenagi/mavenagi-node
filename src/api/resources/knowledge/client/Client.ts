/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as MavenAGI from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Knowledge {
    export interface Options {
        environment?: core.Supplier<environments.MavenAGIEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        appId?: core.Supplier<string | undefined>;
        appSecret?: core.Supplier<string | undefined>;
        /** Override the X-Organization-Id header */
        organizationId: core.Supplier<string>;
        /** Override the X-Agent-Id header */
        agentId: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the X-Organization-Id header */
        organizationId?: string;
        /** Override the X-Agent-Id header */
        agentId?: string;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Knowledge {
    protected readonly _options: Knowledge.Options;

    constructor(_options: Knowledge.Options) {
        this._options = _options;
    }

    /**
     * Update a knowledge base or create it if it doesn't exist.
     *
     * @param {MavenAGI.KnowledgeBaseRequest} request
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.createOrUpdateKnowledgeBase({
     *         knowledgeBaseId: {
     *             referenceId: "help-center"
     *         },
     *         name: "Help center"
     *     })
     */
    public createOrUpdateKnowledgeBase(
        request: MavenAGI.KnowledgeBaseRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<MavenAGI.KnowledgeBaseResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createOrUpdateKnowledgeBase(request, requestOptions));
    }

    private async __createOrUpdateKnowledgeBase(
        request: MavenAGI.KnowledgeBaseRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<MavenAGI.KnowledgeBaseResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                "/v1/knowledge",
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as MavenAGI.KnowledgeBaseResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError("Timeout exceeded when calling PUT /v1/knowledge.");
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get an existing knowledge base by its supplied ID
     *
     * @param {string} knowledgeBaseReferenceId - The reference ID of the knowledge base to get. All other entity ID fields are inferred from the request.
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.getKnowledgeBase("help-center")
     */
    public getKnowledgeBase(
        knowledgeBaseReferenceId: string,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<MavenAGI.KnowledgeBaseResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getKnowledgeBase(knowledgeBaseReferenceId, requestOptions));
    }

    private async __getKnowledgeBase(
        knowledgeBaseReferenceId: string,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<MavenAGI.KnowledgeBaseResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                `/v1/knowledge/${encodeURIComponent(knowledgeBaseReferenceId)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as MavenAGI.KnowledgeBaseResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError(
                    "Timeout exceeded when calling GET /v1/knowledge/{knowledgeBaseReferenceId}.",
                );
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new knowledge base version.
     *
     * If an existing version is in progress, then that version will be finalized in an error state.
     *
     * @param {string} knowledgeBaseReferenceId - The reference ID of the knowledge base to create a version for. All other entity ID fields are inferred from the request.
     * @param {MavenAGI.KnowledgeBaseVersion} request
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.createKnowledgeBaseVersion("help-center", {
     *         versionId: {
     *             type: "KNOWLEDGE_BASE_VERSION",
     *             referenceId: "versionId",
     *             appId: "maven",
     *             organizationId: "acme",
     *             agentId: "support"
     *         },
     *         type: "FULL",
     *         status: "IN_PROGRESS"
     *     })
     */
    public createKnowledgeBaseVersion(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.KnowledgeBaseVersion,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<MavenAGI.KnowledgeBaseVersion> {
        return core.HttpResponsePromise.fromPromise(
            this.__createKnowledgeBaseVersion(knowledgeBaseReferenceId, request, requestOptions),
        );
    }

    private async __createKnowledgeBaseVersion(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.KnowledgeBaseVersion,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<MavenAGI.KnowledgeBaseVersion>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                `/v1/knowledge/${encodeURIComponent(knowledgeBaseReferenceId)}/version`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as MavenAGI.KnowledgeBaseVersion, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError(
                    "Timeout exceeded when calling POST /v1/knowledge/{knowledgeBaseReferenceId}/version.",
                );
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Finalize the latest knowledge base version. Required to indicate the version is complete. Will throw an exception if the latest version is not in progress.
     *
     * @param {string} knowledgeBaseReferenceId - The reference ID of the knowledge base to finalize a version for. All other entity ID fields are inferred from the request.
     * @param {MavenAGI.FinalizeKnowledgeBaseVersionRequest} request
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.finalizeKnowledgeBaseVersion("help-center", {
     *         versionId: {
     *             type: "KNOWLEDGE_BASE_VERSION",
     *             referenceId: "versionId",
     *             appId: "maven"
     *         },
     *         status: "SUCCEEDED"
     *     })
     */
    public finalizeKnowledgeBaseVersion(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.FinalizeKnowledgeBaseVersionRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<MavenAGI.KnowledgeBaseVersion> {
        return core.HttpResponsePromise.fromPromise(
            this.__finalizeKnowledgeBaseVersion(knowledgeBaseReferenceId, request, requestOptions),
        );
    }

    private async __finalizeKnowledgeBaseVersion(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.FinalizeKnowledgeBaseVersionRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<MavenAGI.KnowledgeBaseVersion>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                `/v1/knowledge/${encodeURIComponent(knowledgeBaseReferenceId)}/version/finalize`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as MavenAGI.KnowledgeBaseVersion, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError(
                    "Timeout exceeded when calling POST /v1/knowledge/{knowledgeBaseReferenceId}/version/finalize.",
                );
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create knowledge document. Requires an existing knowledge base with an in progress version. Will throw an exception if the latest version is not in progress.
     *
     * <Tip>
     * This API maintains document version history. If for the same reference ID neither the `title` nor `text` fields
     * have changed, a new document version will not be created. The existing version will be reused.
     * </Tip>
     *
     * @param {string} knowledgeBaseReferenceId - The reference ID of the knowledge base to create a document for. All other entity ID fields are inferred from the request.
     * @param {MavenAGI.KnowledgeDocumentRequest} request
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.createKnowledgeDocument("help-center", {
     *         knowledgeDocumentId: {
     *             referenceId: "getting-started"
     *         },
     *         versionId: {
     *             type: "KNOWLEDGE_BASE_VERSION",
     *             referenceId: "versionId",
     *             appId: "maven"
     *         },
     *         contentType: "MARKDOWN",
     *         content: "## Getting started\\nThis is a getting started guide for the help center.",
     *         title: "Getting started",
     *         metadata: {
     *             "category": "getting-started"
     *         }
     *     })
     */
    public createKnowledgeDocument(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.KnowledgeDocumentRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<MavenAGI.KnowledgeDocumentResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__createKnowledgeDocument(knowledgeBaseReferenceId, request, requestOptions),
        );
    }

    private async __createKnowledgeDocument(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.KnowledgeDocumentRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<MavenAGI.KnowledgeDocumentResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                `/v1/knowledge/${encodeURIComponent(knowledgeBaseReferenceId)}/document`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as MavenAGI.KnowledgeDocumentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError(
                    "Timeout exceeded when calling POST /v1/knowledge/{knowledgeBaseReferenceId}/document.",
                );
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Not yet implemented. Update knowledge document. Requires an existing knowledge base with an in progress version of type PARTIAL. Will throw an exception if the latest version is not in progress.
     *
     * @param {string} knowledgeBaseReferenceId - The reference ID of the knowledge base that contains the document to update. All other entity ID fields are inferred from the request.
     * @param {MavenAGI.KnowledgeDocumentRequest} request
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.updateKnowledgeDocument("help-center", {
     *         knowledgeDocumentId: {
     *             referenceId: "getting-started"
     *         },
     *         versionId: {
     *             type: "KNOWLEDGE_BASE_VERSION",
     *             referenceId: "versionId",
     *             appId: "maven"
     *         },
     *         contentType: "MARKDOWN",
     *         content: "## Getting started\\nThis is a getting started guide for the help center.",
     *         title: "Getting started",
     *         metadata: {
     *             "category": "getting-started"
     *         }
     *     })
     */
    public updateKnowledgeDocument(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.KnowledgeDocumentRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<MavenAGI.KnowledgeDocumentResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateKnowledgeDocument(knowledgeBaseReferenceId, request, requestOptions),
        );
    }

    private async __updateKnowledgeDocument(
        knowledgeBaseReferenceId: string,
        request: MavenAGI.KnowledgeDocumentRequest,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<MavenAGI.KnowledgeDocumentResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                `/v1/knowledge/${encodeURIComponent(knowledgeBaseReferenceId)}/document`,
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as MavenAGI.KnowledgeDocumentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError(
                    "Timeout exceeded when calling PUT /v1/knowledge/{knowledgeBaseReferenceId}/document.",
                );
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Not yet implemented. Delete knowledge document. Requires an existing knowledge base with an in progress version of type PARTIAL. Will throw an exception if the latest version is not in progress.
     *
     * @param {string} knowledgeBaseReferenceId - The reference ID of the knowledge base that contains the document to delete. All other entity ID fields are inferred from the request
     * @param {string} knowledgeDocumentReferenceId - The reference ID of the knowledge document to delete. All other entity ID fields are inferred from the request.
     * @param {Knowledge.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MavenAGI.NotFoundError}
     * @throws {@link MavenAGI.BadRequestError}
     * @throws {@link MavenAGI.ServerError}
     *
     * @example
     *     await client.knowledge.deleteKnowledgeDocument("help-center", "getting-started")
     */
    public deleteKnowledgeDocument(
        knowledgeBaseReferenceId: string,
        knowledgeDocumentReferenceId: string,
        requestOptions?: Knowledge.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(
            this.__deleteKnowledgeDocument(knowledgeBaseReferenceId, knowledgeDocumentReferenceId, requestOptions),
        );
    }

    private async __deleteKnowledgeDocument(
        knowledgeBaseReferenceId: string,
        knowledgeDocumentReferenceId: string,
        requestOptions?: Knowledge.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MavenAGIEnvironment.Production,
                `/v1/knowledge/${encodeURIComponent(knowledgeBaseReferenceId)}/${encodeURIComponent(knowledgeDocumentReferenceId)}/document`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Organization-Id": requestOptions?.organizationId,
                    "X-Agent-Id": requestOptions?.agentId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new MavenAGI.NotFoundError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 400:
                    throw new MavenAGI.BadRequestError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                case 500:
                    throw new MavenAGI.ServerError(
                        _response.error.body as MavenAGI.ErrorMessage,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MavenAGIError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MavenAGIError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MavenAGITimeoutError(
                    "Timeout exceeded when calling DELETE /v1/knowledge/{knowledgeBaseReferenceId}/{knowledgeDocumentReferenceId}/document.",
                );
            case "unknown":
                throw new errors.MavenAGIError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const appId = (await core.Supplier.get(this._options.appId)) ?? process?.env["MAVENAGI_APP_ID"];
        const appSecret = (await core.Supplier.get(this._options.appSecret)) ?? process?.env["MAVENAGI_APP_SECRET"];
        if (appId != null && appSecret != null) {
            return core.BasicAuth.toAuthorizationHeader({
                username: appId,
                password: appSecret,
            });
        }

        return undefined;
    }
}
